<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>	</title>
</head>
<body>
	
</body>
<script type="text/javascript">
	var it=function(){
		return{
			add:function(){
				alert('fdsklfjsdkjfds');
			}
		}
	};
	var t=it();
	t.add();//子对象获取操作
</script>
</html>
//////////////////
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<a href="javascript:myfn()">dsfsdfsd</a>
	<a href="javascript:test();function test(){alert('sdkljflksdjfksdf')};">fsdfdsf</a>  <!--  链接中写js代码 -->
</body>
<script type="text/javascript">
	function myfn(){
		alert('dfslkfjlsdkjf');
	}
</script>
</html>
/////
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	
</body>
<script type="text/javascript">
	(function demo(){
		var name='sdlfkjsdkfj'||'156645';   
		console.log(name); //输出第一个
	})();
</script>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	
</body>
<script type="text/javascript">
	var ctrl={
		fnOne:function(){
			console.log('one');
		},
		fnTwo:function(){
			console.log('two');
		},
		fnThree:function(){
			var t=[1,2,3,4];
			var m=6;
			t.push(m);
			console.log(t)
		}
	};
	ctrl.fnThree()  //调用子对象功能函数
</script>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	
</body>
<script type="text/javascript">
	(function(){
		var t='sdfkjdksjfkjsdkf';
		this.cc='dsflsd;lfksldfk';
	})();
	console.log(this.cc);    //this在匿名函数中指向的是window
</script>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>	</title>
</head>
<style type="text/css">
	.box{
		width:100%;
		height: 100%;
		position: fixed;
		margin:auto;
		top: 0;
		left: 0;
		right:0;
		bottom: 0;
		background: red;
		opacity: 0.6;
		color: black;
	}
</style>
<body>
	<div class="box" id="box">dssdfsdfsdffffffffffffffffffffffffffffffffs</div>
</body>
<script type="text/javascript">
	function _touch(){
		var startx;//让startx在touch事件函数里是全局性变量。
		var endx;
		var el=document.getElementById('box');
		function cons(){   //独立封装这个事件可以保证执行顺序，从而能够访问得到应该访问的数据。
			console.log(starty,endy);
			/*var l=Math.abs(startx-endx);
			var h=Math.abs(starty-endy);
			if(l>h){
				//x事件
				if(startx>endx){
					alert('left');
				}else{
					alert('right');
				}
			}else{
				//y事件
				if(starty>endy){
					alert('top');
				}else{
					alert('bottom');
				}
			}*/
			if(startx>endx){  //判断左右移动程序
				alert('left');
			}else{
				alert('right');
			}
		}
		el.addEventListener('touchstart',function(e){
			var touch=e.changedTouches;
			startx=touch[0].clientX;
			starty=touch[0].clientY;
		});
		el.addEventListener('touchend',function(e){
			var touch=e.changedTouches;
			endx=touch[0].clientX;
			endy=touch[0].clientY;
			cons();  //startx endx 的数据收集应该放在touchend事件后执行，而不是放在touchstart事件里执行，这样才能访问到touchstart和touchend这2个事件产生的startx和endx数据。另外startx和endx在_touch事件函数里是全局性的，所以在此函数中都可以访问得到，所以只需要注意事件执行的先后顺序即可。
		});
	}
	_touch()
</script>


<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <input type="text" id="txt" name='email'>
    <input type="text" id="txt2" name='first'>
    <input type="text" id="txt3" name='space'>
</body>
<script type="text/javascript">
(function() {
    var ipt = document.getElementById('txt');
    ipt.onblur = function() {
        var val = ipt.value;
        console.log(val);
        var re = /(\w+)(@{1})(\w+)(.{1})((com){1})$/;
        sta = re.test(val);
        if (sta) {
        	var el=document.createElement('span');
        	el.innerHTML=sta;
        	function _after(e){
        		ipt.parentNode.insertBefore(e, ipt.nextSibling);
        		//这里的作用是对目标元素的后面追加元素，原理是目标元素的父亲元素内部的元素插入元素
        	};
        	_after(el);
        }else{
        	console.log(sta);
        }
    }
})();
</script>

</html>

</html>
